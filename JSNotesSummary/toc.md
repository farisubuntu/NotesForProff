
## Chapter 1: Getting started with JavaScript

### Section 1.1: Using console.log()
### Section 1.2: Using the DOM API
### Section 1.3: Using window.alert()
### Section 1.4: Using window.prompt()
### Section 1.5: Using window.confirm()
### Section 1.6: Using the DOM API (with graphical text: Canvas, SVG, or image file)

## Chapter 2: JavaScript Variables

### Section 2.1: Defining a Variable
### Section 2.2: Using a Variable
### Section 2.3: Types of Variables
### Section 2.4: Arrays and Objects

## Chapter 3: Built-in Constants

### Section 3.1: null
### Section 3.2: Testing for NaN using isNaN()
### Section 3.3: NaN
### Section 3.4: undefined and null
### Section 3.5: Infinity and -Infinity
### Section 3.6: Number constants
### Section 3.7: Operations that return NaN
### Section 3.8: Math library functions that return NaN

## Chapter 4: Comments

### Section 4.1: Using Commench1_20 copy 2

### Section 5.1: Measuring time - console.time() 2
### Section 5.2: Formatting console output 2
### Section 5.3: Printing to a browser's debugging console 2
### Section 5.4: Including a stack trace when logging - console.trace() 2
### Section 5.5: Tabulating values - console.table() 2
### Section 5.6: Counting - console.count() 2
### Section 5.7: Clearing the console - console.clear() 3
### Section 5.8: Displaying objects and XML interactively - console.dir(), console.dirxml() 3
### Section 5.9: Debugging with assertions - console.assert()

## Chapter 6: Datatypes in JavaScript 3

### Section 6.1: typeof
### Section 6.2: Finding an object's class 3
### Section 6.3: Getting object type by constructor name 3

## Chapter 7: Strings

### Section 7.1: Basic Info and String Concatenation 3
### Section 7.2: Reverse String 3
### Section 7.3: Comparing Strings Lexicographically 3
### Section 7.4: Access character at index in string
### Section 7.5: Escaping quotes 4
### Section 7.6: Word Counter 4
### Section 7.7: Trim whitespace 4
### Section 7.8: Splitting a string into an array 4
### Section 7.9: Strings are unicode 4
### Section 7.10: Detecting a string
### Section 7.11: Substrings with slice
### Section 7.12: Character code 4
### Section 7.13: String Representations of Numbers
### Section 7.14: String Find and Replace Functions 4
### Section 7.15: Find the index of a substring inside a string 4
### Section 7.16: String to Upper Case 4
### Section 7.17: String to Lower Case 4
### Section 7.18: Repeat a String 4

## Chapter 8: Date 4

### Section 8.1: Create a new Date object 4
### Section 8.2: Convert to a string format 4
### Section 8.3: Creating a Date from UTC 5
### Section 8.4: Formatting a JavaScript date 5
### Section 8.5: Get the number of milliseconds elapsed since 1 January 1970 00:00:00 UTC 5
### Section 8.6: Get the current time and date 5
### Section 8.7: Increment a Date Object 5
### Section 8.8: Convert to JSON

## Chapter 9: Date Comparison 5

### Section 9.1: Comparing Date values 5
### Section 9.2: Date Dierence Calculation 5

## Chapter 10: Comparison Operations

### Section 10.1: Abstract equality / inequality and type conversion 6
### Section 10.2: NaN Property of the Global Object 6
### Section 10.3: Short-circuiting in boolean operators
### Section 10.4: Null and Undefined
### Section 10.5: Abstract Equality (==) 6
### Section 10.6: Logic Operators with Booleans 6
### Section 10.7: Automatic Type Conversions 6
### Section 10.8: Logic Operators with Non-boolean values (boolean coercion)
### Section 10.9: Empty Array
### Section 10.10: Equality comparison operations 6
### Section 10.11: Relational operators (<, <=,>, >=) 7
### Section 10.12: Inequality
### Section 10.13: List of Comparison Operators 7
### Section 10.14: Grouping multiple logic statements 7
### Section 10.15: Bit fields to optimise comparison of multi state data

## Chapter 11: Conditions

### Section 11.1: Ternary operators
### Section 11.2: Switch statement 7
### Section 11.3: If / Else If / Else Control
### Section 11.4: Strategy 7
### Section 11.5: Using || and && short circuiting

## Chapter 12: Arrays 8

### Section 12.1: Converting Array-like Objects to Arrays 8
### Section 12.2: Reducing values 8
### Section 12.3: Mapping values
### Section 12.4: Filtering Object Arrays 8
### Section 12.5: Sorting Arrays
### Section 12.6: Iteration 8
### Section 12.7: Destructuring an array
### Section 12.8: Removing duplicate elements
### Section 12.9: Array comparison 9
### Section 12.10: Reversing arrays
### Section 12.11: Shallow cloning an array 9
### Section 12.12: Concatenating Arrays
### Section 12.13: Merge two array as key value pair
### Section 12.14: Array spread / rest 9
### Section 12.15: Filtering values
### Section 12.16: Searching an Array 9
### Section 12.17: Convert a String to an Array 10
### Section 12.18: Removing items from an array 10
### Section 12.19: Removing all elements0
### Section 12.20: Finding the minimum or maximum element0
### Section 12.21: Standard array initialization0
### Section 12.22: Joining array elements in a string 10
### Section 12.23: Removing/Adding elements using splice() 10
### Section 12.24: The entries() method 10
### Section 12.25: Remove value from array0
### Section 12.26: Flattening Arrays 10
### Section 12.27: Append / Prepend items to Array 10
### Section 12.28: Object keys and values to array 10
### Section 12.29: Logical connective of values 10
### Section 12.30: Checking if an object is an Array0
### Section 12.31: Insert an item into an array at a specific index 10
### Section 12.32: Sorting multidimensional array0
### Section 12.33: Test all array items for equality 11
### Section 12.34: Copy part of an Array1

## Chapter 13: Objects 11

### Section 13.1: Shallow cloning1
### Section 13.2: Object.freeze1
### Section 13.3: Object cloning 11
### Section 13.4: Object properties iteration 11
### Section 13.5: Object.assign1
### Section 13.6: Object rest/spread () 11
### Section 13.7: Object.defineProperty1
### Section 13.8: Accesor properties (get and set)1
### Section 13.9: Dynamic / variable property names 11
### Section 13.10: Arrays are Objects 11
### Section 13.11: Object.seal1
### Section 13.12: Convert object's values to array 12
### Section 13.13: Retrieving properties from an object 12
### Section 13.14: Read-Only property 12
### Section 13.15: Non enumerable property2
### Section 13.16: Lock property description 12
### Section 13.17: Object.getOwnPropertyDescriptor 12
### Section 13.18: Descriptors and Named Properties2
### Section 13.19: Object.keys 12
### Section 13.20: Properties with special characters or reserved words 12
### Section 13.21: Creating an Iterable object 12
### Section 13.22: Iterating over Object entries - Object.entries() 12
### Section 13.23: Object.values() 12

## Chapter 14: Arithmetic (Math) 12

### Section 14.1: Constants2
### Section 14.2: Remainder / Modulus (%) 12
### Section 14.3: Rounding3
### Section 14.4: Trigonometry 13
### Section 14.5: Bitwise operators 13
### Section 14.6: Incrementing (++) 13
### Section 14.7: Exponentiation (Math.pow() or **) 13
### Section 14.8: Random Integers and Floats3
### Section 14.9: Addition (+) 13
### Section 14.10: Little / Big endian for typed arrays when using bitwise operators3
### Section 14.11: Get Random Between Two Numbers 13
### Section 14.12: Simulating events with dierent probabilities 13
### Section 14.13: Subtraction (-) 14
### Section 14.14: Multiplication (*) 14
### Section 14.15: Getting maximum and minimum 14
### Section 14.16: Restrict Number to Min/Max Range 14
### Section 14.17: Ceiling and Floor 14
### Section 14.18: Getting roots of a number4
### Section 14.19: Random with gaussian distribution4
### Section 14.20: Math.atan2 to find direction 14
### Section 14.21: Sin & Cos to create a vector given direction & dista 14
### Section 14.22: Math.hypot 14
### Section 14.23: Periodic functions using Math.sin4
### Section 14.24: Division (/) 14
### Section 14.25: Decrementing (--) 14

## Chapter 15: Bitwise operators4

### Section 15.1: Bitwise operators 14
### Section 15.2: Shift Operators 15

## Chapter 16: Constructor functions5

### Section 16.1: Declaring a constructor function 15

## Chapter 17: Declarations and Assignments 15

### Section 17.1: Modifying constants5
### Section 17.2: Declaring and initializing constants 15
### Section 17.3: Declaration5
### Section 17.4: Undefined 15
### Section 17.5: Data Types5
### Section 17.6: Mathematic operations and assignment 15
### Section 17.7: Assignment5

## Chapter 18: Loops 15

### Section 18.1: Standard "for" loops5
### Section 18.2: "for of" loop 15
### Section 18.3: "for in" loop 15
### Section 18.4: "while" Loops 15
### Section 18.5: "continue" a loop 16
### Section 18.6: Break specific nested loops 16
### Section 18.7: "do while" loop6
### Section 18.8: Break and continue labels 16

## Chapter 19: Functions 16

### Section 19.1: Function Scoping6
### Section 19.2: Currying 16
### Section 19.3: Immediately Invoked Function Expressions6
### Section 19.4: Named Functions 16
### Section 19.5: Binding `this` and arguments6
### Section 19.6: Functions with an Unknown Number of Arguments (variadic functions)7
### Section 19.7: Anonymous Function 17
### Section 19.8: Default parameters7
### Section 19.9: Call and apply 17
### Section 19.10: Partial Application 17
### Section 19.11: Passing arguments by reference or value 17
### Section 19.12: Function Arguments, "arguments" object, rest and spread parameters 17
### Section 19.13: Function Composition 17
### Section 19.14: Get the name of a function object 18
### Section 19.15: Recursive Function 18
### Section 19.16: Using the Return Statement8
### Section 19.17: Functions as a variable 18

## Chapter 20: Functional JavaScript 18

### Section 20.1: Higher-Order Functions8
### Section 20.2: Identity Monad 18
### Section 20.3: Pure Functions 18
### Section 20.4: Accepting Functions as Arguments8

## Chapter 21: Prototypes, objects 19

### Section 21.1: Creation and initialising Prototype 19

## Chapter 22: Classes9

### Section 22.1: Class Constructor 19
### Section 22.2: Class Inheritance 19
### Section 22.3: Static Methods 19
### Section 22.4: Getters and Setters9
### Section 22.5: Private Members 19
### Section 22.6: Methods 19
### Section 22.7: Dynamic Method Names9
### Section 22.8: Managing Private Data with Classes 19
### Section 22.9: Class Name binding 19

## Chapter 23: Namespacing 19

### Section 23.1: Namespace by direct assignment9
### Section 23.2: Nested Namespaces 19

## Chapter 24: Context (this) 20

### Section 24.1: this with simple objects 20
### Section 24.2: Saving this for use in nested functions / objects0
### Section 24.3: Binding function context 20
### Section 24.4: this in constructor functi 20

## Chapter 25: Setters and Getters0

### Section 25.1: Defining a Setter/Getter Using Object.defineProperty0
### Section 25.2: Defining an Setter/Getter in a Newly Created Object0
### Section 25.3: Defining getters and setters in ES6 class 20

## Chapter 26: Events 20

### Section 26.1: Page, DOM and Browser loading 20

## Chapter 27: Inheritance 20

### Section 27.1: Standard function prototype0
### Section 27.2: Dierence between Object.key and Object.prototype.key 20
### Section 27.3: Prototypal inheritance 20
### Section 27.4: Pseudo-classical inheritance0
### Section 27.5: Setting an Object's prototype 20

## Chapter 28: Method Chaining 21

### Section 28.1: Chainable object design and chaining1
### Section 28.2: Method Chaining 21

## Chapter 29: Callbacks 21

### Section 29.1: Simple Callback Usage Examples 21
### Section 29.2: Continuation (synchronous and asynchronous)1
### Section 29.3: What is a callback?1
### Section 29.4: Callbacks and `this`1
### Section 29.5: Callback using Arrow function1
### Section 29.6: Error handling and control-flow branching1

## Chapter 30: Intervals and Timeouts 21

### Section 30.1: Recursive setTimeout1
### Section 30.2: Intervals 21
### Section 30.3: Intervals 21
### Section 30.4: Removing intervals2
### Section 30.5: Removing timeouts2
### Section 30.6: setTimeout, order of operations, clearTimeout 22

## Chapter 31: Regular expressions 22

### Section 31.1: Creating a RegExp Object2
### Section 31.2: RegExp Flags 22
### Section 31.3: Check if string contains pattern using .test() 22
### Section 31.4: Matching With .exec()2
### Section 31.5: Using RegExp With Strings 22
### Section 31.6: RegExp Groups 22
### Section 31.7: Replacing string match with a callback function 22
### Section 31.8: Using Regex.exec() with parentheses regex to extract matches of a string 22

## Chapter 32: Cookies2

### Section 32.1: Test if cookies are enabled2
### Section 32.2: Adding and Setting Cookies 22
### Section 32.3: Reading cookies 22
### Section 32.4: Removing cookies 22

## Chapter 33: Web Storage2

### Section 33.1: Using localStorage 22
### Section 33.2: Simpler way of handling Storage 22
### Section 33.3: Storage events 23
### Section 33.4: sessionStorage 23
### Section 33.5: localStorage length3
### Section 33.6: Error conditions 23
### Section 33.7: Clearing storage 23
### Section 33.8: Remove Storage Item 23

## Chapter 34: Data attributes3

### Section 34.1: Accessing data attributes3

## Chapter 35: JSON 23

### Section 35.1: JSON versus JavaScript literals 23
### Section 35.2: Parsing with a reviver function 23
### Section 35.3: Serializing a value3
### Section 35.4: Serializing and restoring class instances 23
### Section 35.5: Serializing with a replacer function 23
### Section 35.6: Parsing a simple JSON string 23
### Section 35.7: Cyclic object values3

## Chapter 36: AJAX 24

### Section 36.1: Sending and Receiving JSON Data via POST4
### Section 36.2: Add an AJAX preloader 24
### Section 36.3: Displaying the top JavaScript questions of the month from Stack Overflow's API 24
### Section 36.4: Using GET with parameters 24
### Section 36.5: Check if a file exists via a HEAD request 24
### Section 36.6: Using GET and no parameters4
### Section 36.7: Listening to AJAX events at a global level 24

## Chapter 37: Enumerations 24

### Section 37.1: Enum definition using Object.freeze() 24
### Section 37.2: Alternate definition 24
### Section 37.3: Printing an enum variable 24
### Section 37.4: Implementing Enums Using Symbols 24
### Section 37.5: Automatic Enumeration Value4

## Chapter 38: Map 24

### Section 38.1: Creating a Map 24
### Section 38.2: Clearing a Map 24
### Section 38.3: Removing an element from a Map 24
### Section 38.4: Checking if a key exists in a Map 24
### Section 38.5: Iterating Maps4
### Section 38.6: Getting and setting elements 24
### Section 38.7: Getting the number of elements of a Map 24

## Chapter 39: Timestamps 25

### Section 39.1: High-resolution timestamps 25
### Section 39.2: Get Timestamp in Seconds5
### Section 39.3: Low-resolution timestamps 25
### Section 39.4: Support for legacy browsers5

## Chapter 40: Unary Operators 25

### Section 40.1: Overview5
### Section 40.2: The typeof operator 25
### Section 40.3: The delete operator 25
### Section 40.4: The unary plus operator (+) 25
### Section 40.5: The void operator 25
### Section 40.6: The unary negation operator (-) 25
### Section 40.7: The bitwise NOT operator (~) 25
### Section 40.8: The logical NOT operator (!)5

## Chapter 41: Generators

### Section 41.1: Generator Functions
### Section 41.2: Sending Values to Generator
### Section 41.3: Delegating to other Generator
### Section 41.4: Iteration
### Section 41.5: Async flow with generators
### Section 41.6: Iterator-Observer interface

## Chapter 42: Promises

### Section 42.1: Introduction
### Section 42.2: Promise chaining
### Section 42.3: Waiting for multiple concurrent promises
### Section 42.4: Reduce an array to chained promises
### Section 42.5: Waiting for the first of multiple concurrent promises
### Section 42.6: "Promisifying" functions with callbacks
### Section 42.7: Error Handling
### Section 42.8: Reconciling synchronous and asynchronous operations
### Section 42.9: Delay function call
### Section 42.10: "Promisifying" values
### Section 42.11: Using ES2017 async/await
### Section 42.12: Performing cleanup with finally()
### Section 42.13: forEach with promises
### Section 42.14: Asynchronous API request

## Chapter 43: Set7

### Section 43.1: Creating a Set
### Section 43.2: Adding a value to a Set
### Section 43.3: Removing value from a set
### Section 43.4: Checking if a value exist in a set
### Section 43.5: Clearing a Set
### Section 43.6: Getting set length
### Section 43.7: Converting Sets to arrays
### Section 43.8: Inter
### Section and dierence in Sets
### Section 43.9: Iterating Sets

## Chapter 44: Modals - Prompts

### Section 44.1: About User Prompts
### Section 44.2: Persistent Prompt Modal
### Section 44.3: Confirm to Delete element
### Section 44.4: Usage of alert()
### Section 44.5: Usage of prompt()

## Chapter 45: execCommand and contenteditable

### Section 45.1: Listening to Changes of contenteditable
### Section 45.2: Getting started
### Section 45.3: Copy to clipboard from textarea using execCommand("copy")
### Section 45.4: Formatting

## Chapter 46: History

### Section 46.1: history.pushState()
### Section 46.2: history.replaceState()
### Section 46.3: Load a specific URL from the history list

## Chapter 47: Navigator Object

### Section 47.1: Get some basic browser data and return it as a JSON object

## Chapter 48: BOM (Browser Object Model)

### Section 48.1: Introduction
### Section 48.2: Window Object Properties
### Section 48.3: Window Object Methods

## Chapter 49: The Event Loop

### Section 49.1: The event loop in a web browser
### Section 49.2: Asynchronous operations and the event loop

## Chapter 50: Strict mode

### Section 50.1: For entire scripts
### Section 50.2: For functions
### Section 50.3: Changes to properties
### Section 50.4: Changes to global properties
### Section 50.5: Duplicate Parameters
### Section 50.6: Function scoping in strict mode
### Section 50.7: Behaviour of a function's arguments list
### Section 50.8: Non-Simple parameter lists

## Chapter 51: Custom Elements

### Section 51.1: Extending Native Elements
### Section 51.2: Registering New Elements

## Chapter 52: Data Manipulation

### Section 52.1: Format numbers as money
### Section 52.2: Extract extension from file name
### Section 52.3: Set object property given its string name

## Chapter 53: Binary Data

### Section 53.1: Getting binary representation of an image file
### Section 53.2: Converting between Blobs and `ArrayBuffers`
### Section 53.3: Manipulating `ArrayBuffers` with DataViews
### Section 53.4: Creating a `TypedArray` from a Base64 string
### Section 53.5: Using `TypedArrays`
### Section 53.6: Iterating through an `arrayBuer`

## Chapter 54: Template Literals

### Section 54.1: Basic interpolation and multiline strings
### Section 54.2: Tagged strings
### Section 54.3: Raw strings
### Section 54.4: Templating HTML With Template Strings
### Section 54.5: Introduction

## Chapter 55: Fetch

### Section 55.1: Getting JSON data
### Section 55.2: Set Request Headers
### Section 55.3: POST Data
### Section 55.4: Send cookies
### Section 55.5: `GlobalFetch`
### Section 55.6: Using Fetch to Display Questions from the Stack Overflow API

## Chapter 56: Scope

### Section 56.1: Closures
### Section 56.2: Hoisting
### Section 56.3: Difference between var and let
### Section 56.4: Apply and Call syntax and invocation
### Section 56.5: Arrow function invocation
### Section 56.6: Bound invocation
### Section 56.7: Method invocation
### Section 56.8: Anonymous invocation2
### Section 56.9: Constructor invocation2
### Section 56.10: Using let in loops instead of var (click handlers example)

## Chapter 57: Modules

### Section 57.1: Defining a module
### Section 57.2: Default exports
### Section 57.3: Importing named members from another module
### Section 57.4: Importing an entire module
### Section 57.5: Importing named members with aliases
### Section 57.6: Importing with side effects
### Section 57.7: Exporting multiple named members

## Chapter 58: Screen

### Section 58.1: Getting the screen resolution
### Section 58.2: Getting the “available” area of the screen
### Section 58.3: Page width and height
### Section 58.4: Window `innerWidth` and `innerHeight` Properties
### Section 58.5: Getting color information about the screen

## Chapter 59: Variable coercion/conversion

### Section 59.1: Double Negation (!!x)
### Section 59.2: Implicit conversion
### Section 59.3: Converting to boolean
### Section 59.4: Converting a string to a number
### Section 59.5: Converting a number to a string
### Section 59.6: Primitive to Primitive conversion table
### Section 59.7: Convert an array to a string
### Section 59.8: Array to String using array methods
### Section 59.9: Converting a number to a boolean
### Section 59.10: Converting a string to a boolean
### Section 59.11: Integer to Float
### Section 59.12: Float to Integer
### Section 59.13: Convert string to float

## Chapter 60: Destructuring assignment

### Section 60.1: Destructuring Objects
### Section 60.2: Destructuring function arguments
### Section 60.3: Nested Destructuring
### Section 60.4: Destructuring Arrays
### Section 60.5: Destructuring inside variables
### Section 60.6: Default Value While Destructuring
### Section 60.7: Renaming Variables While Destructuring

## Chapter 61: WebSockets 33

### Section 61.1: Working with string messages 33
### Section 61.2: Establish a web socket connection 33
### Section 61.3: Working with binary messages 33
### Section 61.4: Making a secure web socket connection 33

## Chapter 62: Arrow Functions 33

### Section 62.1: Introduction 33
### Section 62.2: Lexical Scoping & Binding (Value of "this")3
### Section 62.3: Arguments Object 33
### Section 62.4: Implicit Return3
### Section 62.5: Arrow functions as a constructor 33
### Section 62.6: Explicit Return3

## Chapter 63: Workers 34

### Section 63.1: Web Worker 34
### Section 63.2: A simple service worker 34
### Section 63.3: Register a service worker 34
### Section 63.4: Communicating with a Web Worker 34
### Section 63.5: Terminate a worker4
### Section 63.6: Populating your cache 34
### Section 63.7: Dedicated Workers and Shared Workers4

## Chapter 64: requestAnimationFrame 34

### Section 64.1: Use requestAnimationFrame to fade in element4
### Section 64.2: Keeping Compatibility 34
### Section 64.3: Cancelling an Animation 34

## Chapter 65: Creational Design Patterns4

### Section 65.1: Factory Functions 34
### Section 65.2: Factory with Composition 34
### Section 65.3: Module and Revealing Module Patterns 35
### Section 65.4: Prototype Pattern5
### Section 65.5: Singleton Pattern 35
### Section 65.6: Abstract Factory Pattern5

## Chapter 66: Detecting browser5

### Section 66.1: Feature Detection Method 35
### Section 66.2: User Agent Detection5
### Section 66.3: Library Method 35

## Chapter 67: Symbols 35

### Section 67.1: Basics of symbol primitive type 35
### Section 67.2: Using Symbol.for() to create global, shared symbols 35
### Section 67.3: Converting a symbol into a string5

## Chapter 68: Transpiling 35

### Section 68.1: Introduction to Transpiling 35
### Section 68.2: Start using ES6/7 with Babel6

## Chapter 69: Automatic Semicolon Insertion - ASI 36

### Section 69.1: Avoid semicolon insertion on return statements 36
### Section 69.2: Rules of Automatic Semicolon Insertion 36
### Section 69.3: Statements aected by automatic semicolon insertion6

## Chapter 70: Localization 36

### Section 70.1: Number formatting 36
### Section 70.2: Currency formatting 36
### Section 70.3: Date and time formatting 36

## Chapter 71: Geolocation6

### Section 71.1: Get updates when a user's location changes 36
### Section 71.2: Get a user's latitude and longitude 36
### Section 71.3: More descriptive error codes6

## Chapter 72: IndexedDB 36

### Section 72.1: Opening a database 36
### Section 72.2: Adding objects 36
### Section 72.3: Retrieving data 36
### Section 72.4: Testing for IndexedDB availability6

## Chapter 73: Modularization Techniques7

### Section 73.1: ES6 Modules 37
### Section 73.2: Universal Module Definition (UMD) 37
### Section 73.3: Immediately invoked function expressions (IIFE)7
### Section 73.4: Asynchronous Module Definition (AMD) 37
### Section 73.5: CommonJS - Node.js 37

## Chapter 74: Proxy7
### Section 74.1: Proxying property lookup 37
### Section 74.2: Very simple proxy (using the set trap) 37

## Chapter 75: .postMessage() and MessageEvent 37
### Section 75.1: Getting Started 37

## Chapter 76: WeakMap 37

### Section 76.1: Creating a WeakMap object 37
### Section 76.2: Getting a value associated to the key7
### Section 76.3: Assigning a value to the key7
### Section 76.4: Checking if an element with the key exists 37
### Section 76.5: Removing an element with the key 38
### Section 76.6: Weak reference demo 38

## Chapter 77: WeakSet

### Section 77.1: Creating a WeakSet object8
### Section 77.2: Adding a value 38
### Section 77.3: Checking if a value exists8
### Section 77.4: Removing a value8

## Chapter 78: Escape Sequences

### Section 78.1: Entering special characters in strings and regular expressions8
### Section 78.2: Escape sequence types 38

## Chapter 79: Behavioral Design Patterns


### Section 79.1: Observer pattern 38
### Section 79.2: Mediator Pattern 38
### Section 79.3: Command 38
### Section 79.4: Iterator8

## Chapter 80: Server-sent events 39

### Section 80.1: Setting up a basic event stream to the server 39
### Section 80.2: Closing an event stream9
### Section 80.3: Binding event listeners to EventSource9

## Chapter 81: Async functions (async/await) 39

### Section 81.1: Introduction 39
### Section 81.2: Await and operator precedence9
### Section 81.3: Async functions compared to Promises9
### Section 81.4: Looping with async await9
### Section 81.5: Less indentation9
### Section 81.6: Simultaneous async (parallel) operations9

## Chapter 82: Async Iterators 39

### Section 82.1: Basics 39

## Chapter 83: How to make iterator usable inside async callback function 39

### Section 83.1: Erroneous code, can you spot why this usage of key will lead to bugs? 39
### Section 83.2: Correct Writing 39

## Chapter 84: Tail Call Optimization 40

### Section 84.1: What is Tail Call Optimization (TCO) 40
### Section 84.2: Recursive loops0

## Chapter 85: Bitwise Operators - Real World Examples (snippets)0

### Section 85.1: Swapping Two Integers with Bitwise XOR (without additional memory allocation) 40
### Section 85.2: Faster multiplication or division by powers of0
### Section 85.3: Number's Parity Detection with Bitwise AND0

## Chapter 86: Tilde ~ 40

### Section 86.1: ~ Integer 40
### Section 86.2: ~~ Operator 40
### Section 86.3: Converting Non-numeric values to Numbers0
### Section 86.4: Shorthands 40
### Section 86.5: ~ Decimal 40

## Chapter 87: Using JavaScript to get/set CSS custom variables 40

### Section 87.1: How to get and set CSS variable property values 40

## Chapter 88: Selection API0

### Section 88.1: Get the text of the selection 40
### Section 88.2: Deselect everything that is selected 40
### Section 88.3: Select the contents of an element0

## Chapter 89: File API, Blobs and FileReaders 40

### Section 89.1: Read file as string0
### Section 89.2: Read file as dataURL0
### Section 89.3: Slice a file 40
### Section 89.4: Get the properties of the file0
### Section 89.5: Selecting multiple files and restricting file types 41
### Section 89.6: Client side csv download using Blob 41

## Chapter 90: Notifications API 41

### Section 90.1: Requesting Permission to send notifications 41
### Section 90.2: Sending Notifications1
### Section 90.3: Closing a notification1
### Section 90.4: Notification events 41

## Chapter 91: Vibration API 41

### Section 91.1: Single vibration1
### Section 91.2: Check for support1
### Section 91.3: Vibration patterns1

## Chapter 92: Battery Status API1

### Section 92.1: Battery Events1
### Section 92.2: Getting current battery level1
### Section 92.3: Is battery charging? 41
### Section 92.4: Get time left until battery is empty 41
### Section 92.5: Get time left until battery is fully charged 41

## Chapter 93: Fluent API 41

### Section 93.1: Fluent API capturing construction of HTML articles with JS 41

## Chapter 94: Web Cryptography API 41

### Section 94.1: Creating digests (e.g. SHA-256) 41
### Section 94.2: Cryptographically random data1
### Section 94.3: Generating RSA key pair and converting to PEM format 41
### Section 94.4: Converting PEM key pair to CryptoKey1

## Chapter 95: Security issues 42

### Section 95.1: Reflected Cross-site scripting (XSS) 42
### Section 95.2: Persistent Cross-site scripting (XSS) 42
### Section 95.3: Persistent Cross-site scripting from JavaScript string literals2
### Section 95.4: Why scripts from other people can harm your website and its visitors 42
### Section 95.5: Evaled JSON injection 42

## Chapter 96: Same Origin Policy & Cross-Origin Communication 42

### Section 96.1: Safe cross-origin communication with messages 42
### Section 96.2: Ways to circumvent Same-Origin Policy 42

## Chapter 97: Error Handling 42

### Section 97.1: Error objects2
### Section 97.2: Interaction with Promises 42
### Section 97.3: Error types3
### Section 97.4: Order of operations plus advanced thoughts 43

## Chapter 98: Global error handling in browsers3

### Section 98.1: Handling window.onerror to report all errors back to the server-side 43

## Chapter 99: Debugging 43

### Section 99.1: Interactive interpreter variables 43
### Section 99.2: Breakpoints 43
### Section 99.3: Using setters and getters to find what changed a property 43
### Section 99.4: Using the console3
### Section 99.5: Automatically pausing execution 43
### Section 99.6: Elements inspector 43
### Section 99.7: Break when a function is called 43
### Section 99.8: Stepping through code3

## Chapter 100: Unit Testing JavaScript 44

### Section 100.1: Unit Testing Promises with Mocha, Sinon, Chai and Proxyquire 44
### Section 100.2: Basic Assertion4

## Chapter 101: Evaluating JavaScript

### Section 101.1: Evaluate a string of JavaScript statements 44
### Section 101.2: Introduction4
### Section 101.3: Evaluation and Math 44

## Chapter 102: Linters - Ensuring code quality

### Section 102.1: JSHint
### Section 102.2: ESLint / JSCS
### Section 102.3: JSLint

## Chapter 103: Anti-patterns4

### Section 103.1: Chaining assignments in var declarations 44

## Chapter 104: Performance Tips 44

### Section 104.1: Avoid try/catch in performance-critical functions4
### Section 104.2: Limit DOM Updates 44
### Section 104.3: Benchmarking your code - measuring execution time4
### Section 104.4: Use a memoizer for heavy-computing functions5
### Section 104.5: Initializing object properties with null5
### Section 104.6: Reuse objects rather than recreate 45
### Section 104.7: Prefer local variables to globals, attributes, and indexed values 45
### Section 104.8: Be consistent in use of Numbers 45

## Chapter 105: Memory effeciency 45

### Section 105.1: Drawback of creating true private method 45 Appendix A: Reserved Keywords5
### Section A.1: Reserved Keywords 45
### Section A.2: Identifiers & Identifier Names6
